//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
// 
// Copyright: (c) 2010 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

%ModuleCode
#if !defined(__WXMAC__)
#define wxCURSOR_COPY_ARROW wxCURSOR_ARROW
#endif

%End

//---------------------------------------------------------------------------

class wxPoint
{
%TypeHeaderCode
    #include <wx/gdicmn.h>
%End

public:
    wxPoint();

    wxPoint(
        int x,
        int y
    );

    wxPoint(
        const wxRealPoint & pt
    );

    wxPoint & operator+=(
        const wxPoint & pt
    );

    wxPoint & operator+=(
        const wxSize & sz
    );

    wxPoint & operator-=(
        const wxPoint & pt
    );

    wxPoint & operator-=(
        const wxSize & sz
    );

    bool IsFullySpecified();

    void SetDefaults(
        const wxPoint & pt
    );

    int x;

    int y;

    SIP_PYOBJECT Get();
    %MethodCode
        sipRes = sipBuildResult(&sipIsErr, "(ii)", sipCpp->x, sipCpp->y);
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            if (sipCanConvertToType(sipPy, sipType_wxPoint, SIP_NO_CONVERTORS))
                return 1;
        
            if (PySequence_Check(sipPy) && PySequence_Size(sipPy) == 2) {
                int rval = 1;
                PyObject* o1 = PySequence_ITEM(sipPy, 0);
                PyObject* o2 = PySequence_ITEM(sipPy, 1);
                if (!PyNumber_Check(o1) || !PyNumber_Check(o2)) 
                    rval = 0;
                Py_DECREF(o1);
                Py_DECREF(o2);
                return rval;
            }
            return 0;
        }   
        
        // otherwise do the conversion
        if (PySequence_Check(sipPy)) {
            PyObject* o1 = PySequence_ITEM(sipPy, 0);
            PyObject* o2 = PySequence_ITEM(sipPy, 1);
            *sipCppPtr = new wxPoint(PyInt_AsLong(o1), PyInt_AsLong(o2));
            Py_DECREF(o1);
            Py_DECREF(o2);
            return sipGetState(sipTransferObj);
         }    
         *sipCppPtr = reinterpret_cast<wxPoint*>(sipConvertToType(
                     sipPy, sipType_wxPoint, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
         return 0;
    %End
};  // end of class wxPoint


%Extract pycode
def _Point___str__(self):
    return str(self.Get())
Point.__str__ = _Point___str__

%End

%Extract pycode
def _Point___repr__(self):
    return "wx.Point"+str(self.Get())
Point.__repr__ = _Point___repr__

%End

%Extract pycode
def _Point___len__(self):
    return len(self.Get())
Point.__len__ = _Point___len__

%End

%Extract pycode
def _Point___nonzero__(self):
    return self.Get() != (0,0)
Point.__nonzero__ = _Point___nonzero__

%End

%Extract pycode
def _Point___reduce__(self):
    return (Point, self.Get())
Point.__reduce__ = _Point___reduce__

%End

%Extract pycode
def _Point___getitem__(self, idx):
    return self.Get()[idx]
Point.__getitem__ = _Point___getitem__

%End

%Extract pycode
def _Point___setitem__(self, idx, val):
    if idx == 0: self.x = val
    elif idx == 1: self.y = val
    else: raise IndexError
Point.__setitem__ = _Point___setitem__

%End

%Extract pycode
Point.__safe_for_unpickling__ = True

%End

bool operator==(const wxPoint& p1, const wxPoint& p2);
bool operator!=(const wxPoint& p1, const wxPoint& p2);
wxPoint operator+(const wxPoint& p, const wxSize& s);
wxPoint operator+(const wxPoint& p1, const wxPoint& p2);
wxPoint operator+(const wxSize& s, const wxPoint& p);
wxPoint operator-(const wxPoint& p);
wxPoint operator-(const wxPoint& p, const wxSize& s);
wxPoint operator-(const wxPoint& p1, const wxPoint& p2);
wxPoint operator-(const wxSize& s, const wxPoint& p);
wxPoint operator*(const wxPoint& s, int i);
wxPoint operator*(int i, const wxPoint& s);
wxPoint operator/(const wxPoint& s, int i);


class wxSize
{
%TypeHeaderCode
    #include <wx/gdicmn.h>
%End

public:
    wxSize();

    wxSize(
        int width,
        int height
    );

    void DecBy(
        const wxPoint & pt
    );

    void DecBy(
        const wxSize & size
    );

    void DecBy(
        int dx,
        int dy
    );

    void DecBy(
        int d
    );

    void IncBy(
        const wxPoint & pt
    );

    void IncBy(
        const wxSize & size
    );

    void IncBy(
        int dx,
        int dy
    );

    void IncBy(
        int d
    );

    wxSize & operator+=(
        const wxSize & sz
    );

    wxSize & operator-=(
        const wxSize & sz
    );

    wxSize & operator/=(
        int factor
    );

    wxSize & operator*=(
        int factor
    );

    void DecTo(
        const wxSize & size
    );

    int GetHeight();

    int GetWidth();

    void IncTo(
        const wxSize & size
    );

    bool IsFullySpecified();

    wxSize & Scale(
        float xscale,
        float yscale
    );

    void Set(
        int width,
        int height
    );

    void SetDefaults(
        const wxSize & sizeDefault
    );

    void SetHeight(
        int height
    );

    void SetWidth(
        int width
    );

    %Property(name=width, get=GetWidth, set=SetWidth)

    %Property(name=height, get=GetHeight, set=SetHeight)

    SIP_PYOBJECT Get();
    %MethodCode
        sipRes = sipBuildResult(&sipIsErr, "(ii)", sipCpp->GetWidth(), sipCpp->GetHeight());
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            if (sipCanConvertToType(sipPy, sipType_wxSize, SIP_NO_CONVERTORS))
                return 1;
        
            if (PySequence_Check(sipPy) && PySequence_Size(sipPy) == 2) {
                int rval = 1;
                PyObject* o1 = PySequence_ITEM(sipPy, 0);
                PyObject* o2 = PySequence_ITEM(sipPy, 1);
                if (!PyNumber_Check(o1) || !PyNumber_Check(o2)) 
                    rval = 0;
                Py_DECREF(o1);
                Py_DECREF(o2);
                return rval;
            }
            return 0;
        }   
        
        // otherwise do the conversion
        if (PySequence_Check(sipPy)) {
            PyObject* o1 = PySequence_ITEM(sipPy, 0);
            PyObject* o2 = PySequence_ITEM(sipPy, 1);
            *sipCppPtr = new wxSize(PyInt_AsLong(o1), PyInt_AsLong(o2));
            Py_DECREF(o1);
            Py_DECREF(o2);
            return sipGetState(sipTransferObj);
         }    
         *sipCppPtr = reinterpret_cast<wxSize*>(sipConvertToType(
                     sipPy, sipType_wxSize, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
         return 0;
    %End
};  // end of class wxSize


%Extract pycode
def _Size___str__(self):
    return str(self.Get())
Size.__str__ = _Size___str__

%End

%Extract pycode
def _Size___repr__(self):
    return "wx.Size"+str(self.Get())
Size.__repr__ = _Size___repr__

%End

%Extract pycode
def _Size___len__(self):
    return len(self.Get())
Size.__len__ = _Size___len__

%End

%Extract pycode
def _Size___nonzero__(self):
    return self.Get() != (0,0)
Size.__nonzero__ = _Size___nonzero__

%End

%Extract pycode
def _Size___reduce__(self):
    return (Size, self.Get())
Size.__reduce__ = _Size___reduce__

%End

%Extract pycode
def _Size___getitem__(self, idx):
    return self.Get()[idx]
Size.__getitem__ = _Size___getitem__

%End

%Extract pycode
def _Size___setitem__(self, idx, val):
    if idx == 0: self.width = val
    elif idx == 1: self.height = val
    else: raise IndexError
Size.__setitem__ = _Size___setitem__

%End

%Extract pycode
Size.__safe_for_unpickling__ = True

%End

bool operator==(const wxSize& s1, const wxSize& s2);
bool operator!=(const wxSize& s1, const wxSize& s2);
wxSize operator*(const wxSize& s, int i);
wxSize operator*(int i, const wxSize& s);
wxSize operator+(const wxSize& s1, const wxSize& s2);
wxSize operator-(const wxSize& s1, const wxSize& s2);
wxSize operator/(const wxSize& s, int i);


class wxRect
{
%TypeHeaderCode
    #include <wx/gdicmn.h>
%End

public:
    wxRect();

    wxRect(
        int x,
        int y,
        int width,
        int height
    );

    wxRect(
        const wxPoint & pos,
        const wxSize & size
    );

    wxRect(
        const wxSize & size
    );

    wxRect(
        const wxPoint & topLeft,
        const wxPoint & bottomRight
    );

    wxRect CentreIn(
        const wxRect & r,
        int dir = wxBOTH
    );

    wxRect CenterIn(
        const wxRect & r,
        int dir = wxBOTH
    );

    wxRect & Deflate(
        wxCoord dx,
        wxCoord dy
    );

    wxRect & Deflate(
        const wxSize & diff
    );

    wxRect & Deflate(
        wxCoord diff
    );

    wxRect & Inflate(
        wxCoord dx,
        wxCoord dy
    );

    wxRect & Inflate(
        const wxSize & diff
    );

    wxRect & Inflate(
        wxCoord diff
    );

    void Offset(
        wxCoord dx,
        wxCoord dy
    );

    void Offset(
        const wxPoint & pt
    );

    wxRect & Union(
        const wxRect & rect
    );

    wxRect & operator+=(
        const wxRect & r
    );

    wxRect & operator*=(
        const wxRect & r
    );

    int height;

    int width;

    int x;

    int y;

    bool Contains(
        int x,
        int y
    );

    bool Contains(
        const wxPoint & pt
    );

    bool Contains(
        const wxRect & rect
    );

    int GetBottom();

    wxPoint GetBottomLeft();

    wxPoint GetBottomRight();

    int GetHeight();

    int GetLeft();

    wxPoint GetPosition();

    int GetRight();

    wxSize GetSize();

    int GetTop();

    wxPoint GetTopLeft();

    wxPoint GetTopRight();

    int GetWidth();

    int GetX();

    int GetY();

    wxRect & Intersect(
        const wxRect & rect
    );

    bool Intersects(
        const wxRect & rect
    );

    bool IsEmpty();

    void SetHeight(
        int height
    );

    void SetSize(
        const wxSize & s
    );

    void SetWidth(
        int width
    );

    void SetX(
        int x
    );

    void SetY(
        int y
    );

    %Property(name=left, get=GetLeft)

    %Property(name=top, get=GetTop)

    %Property(name=right, get=GetRight)

    %Property(name=bottom, get=GetBottom)

    %Property(name=bottomLeft, get=GetBottomLeft)

    %Property(name=bottomRight, get=GetBottomRight)

    %Property(name=topLeft, get=GetTopLeft)

    %Property(name=topRight, get=GetTopRight)

    SIP_PYOBJECT Get();
    %MethodCode
        sipRes = sipBuildResult(&sipIsErr, "(iiii)", 
                                sipCpp->x, sipCpp->y, sipCpp->width, sipCpp->height);
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            if (sipCanConvertToType(sipPy, sipType_wxRect, SIP_NO_CONVERTORS))
                return 1;
        
            if (PySequence_Check(sipPy) && PySequence_Size(sipPy) == 4) {
                int rval = 1;
                PyObject* o1 = PySequence_ITEM(sipPy, 0);
                PyObject* o2 = PySequence_ITEM(sipPy, 1);
                PyObject* o3 = PySequence_ITEM(sipPy, 2);
                PyObject* o4 = PySequence_ITEM(sipPy, 3);
                if (!PyNumber_Check(o1) || !PyNumber_Check(o2) || !PyNumber_Check(o3) || !PyNumber_Check(o4)) 
                    rval = 0;
                Py_DECREF(o1);
                Py_DECREF(o2);
                Py_DECREF(o3);
                Py_DECREF(o4);
                return rval;
            }
            return 0;
        }   
        
        // otherwise do the conversion
        if (PySequence_Check(sipPy)) {
            PyObject* o1 = PySequence_ITEM(sipPy, 0);
            PyObject* o2 = PySequence_ITEM(sipPy, 1);
            PyObject* o3 = PySequence_ITEM(sipPy, 2);
            PyObject* o4 = PySequence_ITEM(sipPy, 3);       
            *sipCppPtr = new wxRect(PyInt_AsLong(o1), PyInt_AsLong(o2),
                                     PyInt_AsLong(o3), PyInt_AsLong(o4));
            Py_DECREF(o1);
            Py_DECREF(o2);
            return sipGetState(sipTransferObj);
         }    
         *sipCppPtr = reinterpret_cast<wxRect*>(sipConvertToType(
                     sipPy, sipType_wxRect, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
         return 0;
    %End
};  // end of class wxRect


%Extract pycode
def _Rect___str__(self):
    return str(self.Get())
Rect.__str__ = _Rect___str__

%End

%Extract pycode
def _Rect___repr__(self):
    return "wx.Rect"+str(self.Get())
Rect.__repr__ = _Rect___repr__

%End

%Extract pycode
def _Rect___len__(self):
    return len(self.Get())
Rect.__len__ = _Rect___len__

%End

%Extract pycode
def _Rect___nonzero__(self):
    return self.Get() != (0,0,0,0)
Rect.__nonzero__ = _Rect___nonzero__

%End

%Extract pycode
def _Rect___reduce__(self):
    return (Rect, self.Get())
Rect.__reduce__ = _Rect___reduce__

%End

%Extract pycode
def _Rect___getitem__(self, idx):
    return self.Get()[idx]
Rect.__getitem__ = _Rect___getitem__

%End

%Extract pycode
def _Rect___setitem__(self, idx, val):
    if idx == 0: self.x = val
    elif idx == 1: self.y = val
    elif idx == 2: self.width = val
    elif idx == 3: self.height = val
    else: raise IndexError
Rect.__setitem__ = _Rect___setitem__

%End

%Extract pycode
Rect.__safe_for_unpickling__ = True

%End

bool operator==(const wxRect& r1, const wxRect& r2);
bool operator!=(const wxRect& r1, const wxRect& r2);
wxRect operator+(const wxRect& r1, const wxRect& r2);
wxRect operator*(const wxRect& r1, const wxRect& r2);


class wxRealPoint
{
%TypeHeaderCode
    #include <wx/gdicmn.h>
%End

public:
    wxRealPoint();

    wxRealPoint(
        double x,
        double y
    );

    wxRealPoint(
        const wxPoint & pt
    );

    wxRealPoint & operator+=(
        const wxRealPoint & pt
    );

    wxRealPoint & operator+=(
        const wxSize & sz
    );

    wxRealPoint & operator-=(
        const wxRealPoint & pt
    );

    wxRealPoint & operator-=(
        const wxSize & sz
    );

    double x;

    double y;

    SIP_PYOBJECT Get();
    %MethodCode
        sipRes = sipBuildResult(&sipIsErr, "(dd)", 
                                sipCpp->x, sipCpp->y);
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            if (sipCanConvertToType(sipPy, sipType_wxRealPoint, SIP_NO_CONVERTORS))
                return 1;
        
            if (PySequence_Check(sipPy) && PySequence_Size(sipPy) == 2) {
                int rval = 1;
                PyObject* o1 = PySequence_ITEM(sipPy, 0);
                PyObject* o2 = PySequence_ITEM(sipPy, 1);
                if (!PyNumber_Check(o1) || !PyNumber_Check(o2)) 
                    rval = 0;
                Py_DECREF(o1);
                Py_DECREF(o2);
                return rval;
            }
            return 0;
        }   
        
        // otherwise do the conversion
        if (PySequence_Check(sipPy)) {
            PyObject* o1 = PySequence_ITEM(sipPy, 0);
            PyObject* o2 = PySequence_ITEM(sipPy, 1);
            *sipCppPtr = new wxRealPoint(PyFloat_AsDouble(o1), PyFloat_AsDouble(o2));
            Py_DECREF(o1);
            Py_DECREF(o2);
            return sipGetState(sipTransferObj);
         }    
         *sipCppPtr = reinterpret_cast<wxRealPoint*>(sipConvertToType(
                     sipPy, sipType_wxRealPoint, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
         return 0;
    %End
};  // end of class wxRealPoint


%Extract pycode
def _RealPoint___str__(self):
    return str(self.Get())
RealPoint.__str__ = _RealPoint___str__

%End

%Extract pycode
def _RealPoint___repr__(self):
    return "wx.RealPoint"+str(self.Get())
RealPoint.__repr__ = _RealPoint___repr__

%End

%Extract pycode
def _RealPoint___len__(self):
    return len(self.Get())
RealPoint.__len__ = _RealPoint___len__

%End

%Extract pycode
def _RealPoint___nonzero__(self):
    return self.Get() != (0,0)
RealPoint.__nonzero__ = _RealPoint___nonzero__

%End

%Extract pycode
def _RealPoint___reduce__(self):
    return (Rect, self.Get())
RealPoint.__reduce__ = _RealPoint___reduce__

%End

%Extract pycode
def _RealPoint___getitem__(self, idx):
    return self.Get()[idx]
RealPoint.__getitem__ = _RealPoint___getitem__

%End

%Extract pycode
def _RealPoint___setitem__(self, idx, val):
    if idx == 0: self.x = val
    elif idx == 1: self.y = val
    else: raise IndexError
RealPoint.__setitem__ = _RealPoint___setitem__

%End

%Extract pycode
RealPoint.__safe_for_unpickling__ = True

%End

bool operator==(const wxRealPoint& p1, const wxRealPoint& p2);
bool operator!=(const wxRealPoint& p1, const wxRealPoint& p2);
wxRealPoint operator*(const wxRealPoint& s, double i);
wxRealPoint operator*(double i, const wxRealPoint& s);
wxRealPoint operator+(const wxRealPoint& p1, const wxRealPoint& p2);
wxRealPoint operator-(const wxRealPoint& p1, const wxRealPoint& p2);
wxRealPoint operator/(const wxRealPoint& s, int i);


enum wxBitmapType
{
    wxBITMAP_TYPE_INVALID,
    wxBITMAP_TYPE_BMP,
    wxBITMAP_TYPE_ICO,
    wxBITMAP_TYPE_CUR,
    wxBITMAP_TYPE_XBM,
    wxBITMAP_TYPE_XBM_DATA,
    wxBITMAP_TYPE_XPM,
    wxBITMAP_TYPE_XPM_DATA,
    wxBITMAP_TYPE_TIF,
    wxBITMAP_TYPE_GIF,
    wxBITMAP_TYPE_PNG,
    wxBITMAP_TYPE_JPEG,
    wxBITMAP_TYPE_PNM,
    wxBITMAP_TYPE_PCX,
    wxBITMAP_TYPE_PICT,
    wxBITMAP_TYPE_ICON,
    wxBITMAP_TYPE_ANI,
    wxBITMAP_TYPE_IFF,
    wxBITMAP_TYPE_TGA,
    wxBITMAP_TYPE_MACCURSOR,
    wxBITMAP_TYPE_ANY
};

enum wxPolygonFillMode
{
    wxODDEVEN_RULE,
    wxWINDING_RULE
};

enum wxStockCursor
{
    wxCURSOR_NONE,
    wxCURSOR_ARROW,
    wxCURSOR_RIGHT_ARROW,
    wxCURSOR_BULLSEYE,
    wxCURSOR_CHAR,
    wxCURSOR_CROSS,
    wxCURSOR_HAND,
    wxCURSOR_IBEAM,
    wxCURSOR_LEFT_BUTTON,
    wxCURSOR_MAGNIFIER,
    wxCURSOR_MIDDLE_BUTTON,
    wxCURSOR_NO_ENTRY,
    wxCURSOR_PAINT_BRUSH,
    wxCURSOR_PENCIL,
    wxCURSOR_POINT_LEFT,
    wxCURSOR_POINT_RIGHT,
    wxCURSOR_QUESTION_ARROW,
    wxCURSOR_RIGHT_BUTTON,
    wxCURSOR_SIZENESW,
    wxCURSOR_SIZENS,
    wxCURSOR_SIZENWSE,
    wxCURSOR_SIZEWE,
    wxCURSOR_SIZING,
    wxCURSOR_SPRAYCAN,
    wxCURSOR_WAIT,
    wxCURSOR_WATCH,
    wxCURSOR_BLANK,
    wxCURSOR_DEFAULT,
    wxCURSOR_COPY_ARROW,
    wxCURSOR_ARROWWAIT,
    wxCURSOR_MAX
};

const wxPoint wxDefaultPosition;

const wxSize wxDefaultSize;

bool wxColourDisplay();

int wxDisplayDepth();

void wxClientDisplayRect(
    int * x   /Out/,
    int * y   /Out/,
    int * width   /Out/,
    int * height   /Out/
);

wxRect wxGetClientDisplayRect();

wxSize wxGetDisplayPPI();

void wxDisplaySize(
    int * width   /Out/,
    int * height   /Out/
);

wxSize wxGetDisplaySize();

void wxDisplaySizeMM(
    int * width   /Out/,
    int * height   /Out/
);

wxSize wxGetDisplaySizeMM();


//---------------------------------------------------------------------------

